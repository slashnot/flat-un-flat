{"version":3,"file":"flat-un-flat.js","sources":["../src/flatten.ts","../src/main.ts","../src/unflatten.ts"],"sourcesContent":["import type { FlatObject, NestedObject } from './types';\r\n\r\nexport function flattenObject(obj: NestedObject, parentKey: string = '', flatObj: FlatObject = {}): FlatObject {\r\n    for (const key in obj) {\r\n        const newKey = parentKey ? `${parentKey}.${key}` : key;\r\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n            // Recursively flatten the object\r\n            flattenObject(obj[key], newKey, flatObj);\r\n        } else {\r\n            // Add non-object value to the flattened object\r\n            flatObj[newKey] = obj[key];\r\n        }\r\n    }\r\n    return flatObj;\r\n}\r\n\r\nexport function flattenObjectWithArray(obj: NestedObject, parentKey: string = '', flatObj: FlatObject = {}): FlatObject {\r\n    for (const key in obj) {\r\n        const newKey = parentKey ? `${parentKey}.${key}` : key;\r\n\r\n        if (Array.isArray(obj[key])) {\r\n            // Include arrays directly as values without flattening further.\r\n            flatObj[newKey] = obj[key];\r\n        } else if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n            // Recursively flatten the object\r\n            flattenObjectWithArray(obj[key], newKey, flatObj);\r\n        } else {\r\n            // Add non-object values and non-array values to the flattened object.\r\n            flatObj[newKey] = obj[key];\r\n        }\r\n    }\r\n    return flatObj;\r\n}","import { flattenObjectWithArray } from './flatten';\r\nimport { flattenObject as simpleFlattenObject } from './flatten';\r\nimport type { NestedObject, FlatObject } from './types';\r\n\r\n/**\r\n * Flattens a nested object into a single-level object with dot-notation keys.\r\n *\r\n * @param object - The nested object to flatten\r\n * @param options - Configuration options for flattening behavior\r\n * @param options.preserveArrays - When true, arrays are preserved as values without flattening. When false (default), arrays are flattened into individual keys\r\n * @returns A flattened object with dot-notation keys\r\n *\r\n * @example\r\n * // Without preserveArrays (default)\r\n * flattenObject({ a: { b: 1, c: [2, 3] } })\r\n * // => { 'a.b': 1, 'a.c.0': 2, 'a.c.1': 3 }\r\n *\r\n * @example\r\n * // With preserveArrays\r\n * flattenObject({ a: { b: 1, c: [2, 3] } }, { preserveArrays: true })\r\n * // => { 'a.b': 1, 'a.c': [2, 3] }\r\n */\r\nexport const flattenObject = (object: NestedObject, options = { preserveArrays: false }): FlatObject => {\r\n    const { preserveArrays } = options;\r\n\r\n    if (preserveArrays) {\r\n        return flattenObjectWithArray(object);\r\n    } else {\r\n        return simpleFlattenObject(object);\r\n    }\r\n}","import type { FlatObject, NestedObject } from './types';\r\n\r\n/**\r\n * Unflattens a flat object with dot-notation (or custom separator) keys back into a nested object structure.\r\n *\r\n * @param flatObj - The flat object with dot-notation keys to unflatten\r\n * @param separator - The separator used in the flattened keys (default: '.')\r\n * @returns A nested object structure reconstructed from the flat object\r\n *\r\n * @example\r\n * // Using default separator\r\n * unflattenObject({ 'a.b': 1, 'a.c': 2, 'd': 3 })\r\n * // => { a: { b: 1, c: 2 }, d: 3 }\r\n *\r\n * @example\r\n * // Using custom separator\r\n * unflattenObject({ 'a_b': 1, 'a_c': 2 }, '_')\r\n * // => { a: { b: 1, c: 2 } }\r\n */\r\nexport function unflattenObject(flatObj: FlatObject, separator: string = '.'): NestedObject {\r\n    const unflattened: NestedObject = {};\r\n\r\n    for (const key in flatObj) {\r\n        // Split the keys by '.' to get individual levels.\r\n        const path = key.split(separator);\r\n        let currentLevel: NestedObject = unflattened;\r\n\r\n        // Iterate over each level, creating nested objects as needed.\r\n        path.forEach((subKey, index) => {\r\n            if (index === path.length - 1) {\r\n                // Last segment: assign the value directly\r\n                currentLevel[subKey] = flatObj[key];\r\n            } else {\r\n                // Create an empty object for this key if it doesn't exist yet\r\n                if (!currentLevel[subKey]) {\r\n                    currentLevel[subKey] = {};\r\n                }\r\n                // Move to the next level in the nested structure\r\n                currentLevel = currentLevel[subKey];\r\n            }\r\n        });\r\n    }\r\n\r\n    // Convert objects with consecutive numeric keys starting from 0 into arrays\r\n    return convertToArrays(unflattened);\r\n}\r\n\r\n/**\r\n * Helper function to recursively convert objects with consecutive numeric keys into arrays\r\n */\r\nfunction convertToArrays(obj: any): any {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    // First, recursively process all nested objects\r\n    for (const key in obj) {\r\n        obj[key] = convertToArrays(obj[key]);\r\n    }\r\n\r\n    // Check if this object should be converted to an array\r\n    const keys = Object.keys(obj);\r\n    \r\n    // Check if all keys are numeric and consecutive starting from 0\r\n    if (keys.length > 0) {\r\n        const numericKeys = keys.map(k => parseInt(k, 10));\r\n        const allNumeric = numericKeys.every((num, idx) => !isNaN(num) && keys[idx] === String(num));\r\n        \r\n        if (allNumeric) {\r\n            numericKeys.sort((a, b) => a - b);\r\n            const isConsecutive = numericKeys.every((num, idx) => num === idx);\r\n            \r\n            if (isConsecutive && numericKeys[0] === 0) {\r\n                // Convert to array\r\n                return numericKeys.map(i => obj[String(i)]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return obj;\r\n}"],"names":["flattenObject","obj","parentKey","flatObj","key","newKey","flattenObjectWithArray","object","options","preserveArrays","simpleFlattenObject","unflattenObject","separator","unflattened","path","currentLevel","subKey","index","convertToArrays","keys","numericKeys","k","num","idx","a","b","i"],"mappings":"AAEO,SAASA,EAAcC,GAAmBC,IAAoB,IAAIC,IAAsB,CAAA,GAAgB;AAC3G,aAAWC,KAAOH,GAAK;AACnB,UAAMI,IAASH,IAAY,GAAGA,CAAS,IAAIE,CAAG,KAAKA;AACnD,IAAI,OAAOH,EAAIG,CAAG,KAAM,YAAYH,EAAIG,CAAG,MAAM,OAE7CJ,EAAcC,EAAIG,CAAG,GAAGC,GAAQF,CAAO,IAGvCA,EAAQE,CAAM,IAAIJ,EAAIG,CAAG;AAAA,EAEjC;AACA,SAAOD;AACX;AAEO,SAASG,EAAuBL,GAAmBC,IAAoB,IAAIC,IAAsB,CAAA,GAAgB;AACpH,aAAWC,KAAOH,GAAK;AACnB,UAAMI,IAASH,IAAY,GAAGA,CAAS,IAAIE,CAAG,KAAKA;AAEnD,IAAI,MAAM,QAAQH,EAAIG,CAAG,CAAC,IAEtBD,EAAQE,CAAM,IAAIJ,EAAIG,CAAG,IAClB,OAAOH,EAAIG,CAAG,KAAM,YAAYH,EAAIG,CAAG,MAAM,OAEpDE,EAAuBL,EAAIG,CAAG,GAAGC,GAAQF,CAAO,IAGhDA,EAAQE,CAAM,IAAIJ,EAAIG,CAAG;AAAA,EAEjC;AACA,SAAOD;AACX;ACVO,MAAMH,IAAgB,CAACO,GAAsBC,IAAU,EAAE,gBAAgB,SAAwB;AACpG,QAAM,EAAE,gBAAAC,MAAmBD;AAE3B,SAAIC,IACOH,EAAuBC,CAAM,IAE7BG,EAAoBH,CAAM;AAEzC;ACXO,SAASI,EAAgBR,GAAqBS,IAAoB,KAAmB;AACxF,QAAMC,IAA4B,CAAA;AAElC,aAAWT,KAAOD,GAAS;AAEvB,UAAMW,IAAOV,EAAI,MAAMQ,CAAS;AAChC,QAAIG,IAA6BF;AAGjC,IAAAC,EAAK,QAAQ,CAACE,GAAQC,MAAU;AAC5B,MAAIA,MAAUH,EAAK,SAAS,IAExBC,EAAaC,CAAM,IAAIb,EAAQC,CAAG,KAG7BW,EAAaC,CAAM,MACpBD,EAAaC,CAAM,IAAI,CAAA,IAG3BD,IAAeA,EAAaC,CAAM;AAAA,IAE1C,CAAC;AAAA,EACL;AAGA,SAAOE,EAAgBL,CAAW;AACtC;AAKA,SAASK,EAAgBjB,GAAe;AACpC,MAAIA,MAAQ,QAAQ,OAAOA,KAAQ;AAC/B,WAAOA;AAIX,aAAWG,KAAOH;AACd,IAAAA,EAAIG,CAAG,IAAIc,EAAgBjB,EAAIG,CAAG,CAAC;AAIvC,QAAMe,IAAO,OAAO,KAAKlB,CAAG;AAG5B,MAAIkB,EAAK,SAAS,GAAG;AACjB,UAAMC,IAAcD,EAAK,IAAI,OAAK,SAASE,GAAG,EAAE,CAAC;AAGjD,QAFmBD,EAAY,MAAM,CAACE,GAAKC,MAAQ,CAAC,MAAMD,CAAG,KAAKH,EAAKI,CAAG,MAAM,OAAOD,CAAG,CAAC,MAGvFF,EAAY,KAAK,CAACI,GAAGC,MAAMD,IAAIC,CAAC,GACVL,EAAY,MAAM,CAACE,GAAKC,MAAQD,MAAQC,CAAG,KAE5CH,EAAY,CAAC,MAAM;AAEpC,aAAOA,EAAY,IAAI,CAAAM,MAAKzB,EAAI,OAAOyB,CAAC,CAAC,CAAC;AAAA,EAGtD;AAEA,SAAOzB;AACX;"}